#include "CellularAutomata/CADataPrinter.h"
#include "CellularAutomata/Solvers/AMXSolver.h"
#include "Memory/Allocators/CPUAllocator.h"

AMXSolver::AMXSolver(CADataDomain<uint8_t>* domain, CADataDomain<uint8_t>* domainBuffer) {
    dataDomain = domain;
    dataDomainBuffer = domainBuffer;

    CPUAllocator<int>* cpuAllocator = new CPUAllocator<int>();
    Allocator<int>* allocator = reinterpret_cast<Allocator<int>*>(cpuAllocator);
    hostVisibleData = new CADataDomain<int>(allocator, dataDomain->getInnerHorizontalSize(), dataDomain->getHorizontalHaloSize());
    hostVisibleData->allocate();

	lDebug(1, "Setting up AMX");
    setupAMX();
    
	lDebug(1, "Filing Tridiag matrices");
    fillTridiag();
}

void AMXSolver::setupAMX() {
	tile_config = new __tile_config();
    tile_config->palette_id = 1;
    tile_config->start_row = 0;

    // Configure tiles for block_size x block_size matrices
    for (int i = 0; i < 1; ++i) {
        tile_config->colsb[i] = 16 * 4;
        tile_config->rows[i] = 16;
    }

    for (int i = 1; i < 8; ++i) {
        tile_config->colsb[i] = 64;
        tile_config->rows[i] = 16;
    }

    _tile_loadconfig(tile_config);

    if (syscall(SYS_arch_prctl, ARCH_REQ_XCOMP_PERM, XFEATURE_XTILEDATA))
	{
	   printf("\n Failed to enable XFEATURE_XTILEDATA \n\n");
	}
	else
	{
	   printf("\n TILE DATA USE SET - OK \n\n");
	}

}


void AMXSolver::fillTridiag() {
		printf("HERE!\n");
	uint8_t* data = (uint8_t*) malloc(64*16*6*sizeof(uint8_t));
	uint8_t* dataA = (uint8_t*) malloc(64*16*6*sizeof(uint8_t));
	pi_1_asA  = &dataA[64*16*0];
	pi_2_asA  = &dataA[64*16*1];
	pi_3_asA  = &dataA[64*16*2];
	pi_4_asA  = &dataA[64*16*3];
	pi_5_asA  = &dataA[64*16*4];
	pi_6_asA  = &dataA[64*16*5];
	pi_1_asB  = &data[64*16*0];
	pi_2_asB  = &data[64*16*1];
	pi_3_asB  = &data[64*16*2];
	pi_4_asB  = &data[64*16*3];
	pi_5_asB  = &data[64*16*4];
	pi_6_asB  = &data[64*16*5];
    int i;

    for (i = 0; i < 16*64; i += 1)
    {
        int col = i & 63;
        int row = i >> 6;
        if (col + 63 - RADIUS < row + 16*3){
            pi_1_asA[i] = 1;
        } else {
            pi_1_asA[i] = 0;
        }

        if (abs(col - row) <= RADIUS){
            pi_2_asA[i] = 1;
        } else {
            pi_2_asA[i] = 0;
        }
        if (abs(col - row-16) <= RADIUS){
            pi_3_asA[i] = 1;
        } else {
            pi_3_asA[i] = 0;
        }
        if (abs(col - row-32) <= RADIUS){
            pi_4_asA[i] = 1;
        } else {
            pi_4_asA[i] = 0;
        }
        if (abs(col - row-48) <= RADIUS){
            pi_5_asA[i] = 1;
        } else {
            pi_5_asA[i] = 0;
        }

        if (col -63+RADIUS> row){
            pi_6_asA[i] = 1;
        } else {
            pi_6_asA[i] = 0;
        }
    }

    for (i = 0; i < 16; i += 1)
    {
		for (int j = 0; j < 64; j++){
			pi_1_asB[j*16+ i] = pi_1_asA[i*64 + j];
			pi_2_asB[j*16+ i] = pi_1_asA[i*64 + j];
			pi_3_asB[j*16+ i] = pi_1_asA[i*64 + j];
			pi_4_asB[j*16+ i] = pi_1_asA[i*64 + j];
			pi_5_asB[j*16+ i] = pi_1_asA[i*64 + j];
			pi_6_asB[j*16+ i] = pi_1_asA[i*64 + j];
		}
    }
    // // debug print tridiag in 2d
     for (int i = 0; i < 64; i++) {
         for (int j = 0; j < 16; j++) {
             std::cout << (int)pi_1_asA[i * 16 + j] << " ";
         }
         std::cout << std::endl;
     }
         std::cout << std::endl;

     for (int i = 0; i < 64; i++) {
         for (int j = 0; j < 16; j++) {
             std::cout << (int)pi_2_asA[i * 16 + j] << " ";
         }
         std::cout << std::endl;
     }
         std::cout << std::endl;

     for (int i = 0; i < 64; i++) {
         for (int j = 0; j < 16; j++) {
             std::cout << (int)pi_3_asA[i * 16 + j] << " ";
         }
         std::cout << std::endl;
     }
         std::cout << std::endl;
     for (int i = 0; i < 64; i++) {
         for (int j = 0; j < 16; j++) {
             std::cout << (int)pi_4_asA[i * 16 + j] << " ";
         }
         std::cout << std::endl;
     }
         std::cout << std::endl;
     for (int i = 0; i < 64; i++) {
         for (int j = 0; j < 16; j++) {
             std::cout << (int)pi_5_asA[i * 16 + j] << " ";
         }
         std::cout << std::endl;
     }
         std::cout << std::endl;
     for (int i = 0; i < 64; i++) {
         for (int j = 0; j < 16; j++) {
             std::cout << (int)pi_6_asA[i * 16 + j] << " ";
         }
         std::cout << std::endl;
     }


}

void AMXSolver::copyCurrentStateToHostVisibleData() {
	lDebug(1, "%llu\n", dataDomain->getTotalSize());
    for (int i = 0; i < dataDomain->getTotalSize(); ++i) {
        uint8_t value = dataDomain->getElementAt(i);
        hostVisibleData->setElementAt(i, (int)value);
    }
}
void AMXSolver::copyHostVisibleDataToCurrentState() {
    for (int i = 0; i < hostVisibleData->getTotalSize(); ++i) {
        int value = hostVisibleData->getElementAt(i);
        dataDomain->setElementAt(i, value);
    }
}

void AMXSolver::swapPointers() {
    CADataDomain<uint8_t>* temp = dataDomain;
    dataDomain = dataDomainBuffer;
    dataDomainBuffer = temp;
}

uint8_t AMXSolver::transitionFunction(int k, int a, int b) {
    return (1 - (((k - a) >> 31) & 0x1)) * (1 - (((b - k) >> 31) & 0x1));
}

int buffer[16*16];

void AMXSolver::CAStepAlgorithm() {
    uint8_t* data = dataDomain->getData();
    uint8_t* dataBuffer = dataDomainBuffer->getData();
    size_t nWithHalo = dataDomain->getFullHorizontalSize();

    _tile_loadd(1, pi_1_asB, 16);
    _tile_loadd(2, pi_2_asB, 16);
    _tile_loadd(3, pi_3_asB, 16);
    _tile_loadd(4, pi_4_asB, 16);
    _tile_loadd(5, pi_5_asB, 16);
    _tile_loadd(6, pi_6_asB, 16);

    printf("nWithHalo: %llu\n", nWithHalo);
    //FIRST STEP: horizontal reduction
    for (int i = 0; i < nWithHalo; i+=64) {
        for (int j = 0; j < nWithHalo - 64*2; j+=64) {
            //take three continuous 16x16 blocks and load them into amx

	    	printf("%i, %i\n", i, j);
		    // tiles in C from 0,0 to 3,0 (first col)
			for (int k  = 0; k < 4; k++){
            	_tile_zero(0);
				printf("first col: %llu\n", (i+16*k) * nWithHalo + j + 64);

				for (int ii=0; ii<16; ii++){
					for (int jj=0; jj<64; jj++){
						//printf("%i ", data[(i+ii+16*k) * nWithHalo + j+jj]);
					}
					//printf("\n");
				}
				for (int ii=0; ii<16*64; ii++){
					//printf("%i ", pi_2_asB[ii]);
					//9if (ii%16 == 15)
						//printf("\n");
				}
				//_tile_loadd(7, &data[(i+16*k) * nWithHalo + j], nWithHalo);
				//_tile_dpbssd(0, 7, 1);
				_tile_loadd(7, &data[(i+16*k) * nWithHalo + j + 64], nWithHalo);
				_tile_dpbssd(0, 7, 2);
				_tile_stored(0, &buffer, 16*4);
				//_tile_stored(0, &dataBuffer[(i+16*k) * nWithHalo + j + 64], nWithHalo);


				for (int ii=0; ii<16; ii++){
					for (int jj=0; jj<16; jj++){
						printf("%i ", buffer[ii*16+jj]);
					}
					printf("\n");
				}
			}
        //    _tile_zero(0);
		//    // tiles in C from 0,1 to 3,1 (first col)
		//	for (int k  = 0; k < 4; k++){
		//		_tile_loadd(7, &data[(i+16*k) * nWithHalo + j + 64], nWithHalo);
		//		_tile_dpbssd(0, 7, 3);
		//		_tile_stored(0, &dataBuffer[(i+16*k) * nWithHalo + j + 64 + 16], nWithHalo);
		//		printf("second col: %llu\n", (i+16*k) * nWithHalo + j + 64 + 16);
		//	}
        //    _tile_zero(0);
		//    // tiles in C from 0,2 to 3,2 (first col)
		//	for (int k  = 0; k < 4; k++){
		//		_tile_loadd(7, &data[(i+16*k) * nWithHalo + j + 64], nWithHalo);
		//		_tile_dpbssd(0, 7, 4);
		//		_tile_stored(0, &dataBuffer[(i+16*k) * nWithHalo + j + 64 +32], nWithHalo);
		//		printf("third col: %llu\n", (i+16*k) * nWithHalo + j + 64 + 32);
		//	}
        //    _tile_zero(0);
		//    // tiles in C from 0,3 to 3,3 (first col)
		//	for (int k  = 0; k < 4; k++){
		//		_tile_loadd(7, &data[(i+16*k) * nWithHalo + j + 64], nWithHalo);
		//		_tile_dpbssd(0, 7, 5);
		//		_tile_loadd(7, &data[(i+16*k) * nWithHalo + j + 128], nWithHalo);
		//		_tile_dpbssd(0, 7, 1);
		//		_tile_stored(0, &dataBuffer[(i+16*k) * nWithHalo + j + 64+48], nWithHalo);
		//		printf("fourth col: %llu\n", (i+16*k) * nWithHalo + j + 64 + 48);
		//	}
        }
    }

    printf("DFONE\n");

    // for (int i = 0; i < dataDomain->getInnerHorizontalSize(); ++i) {
    //     for (int j = 0; j < dataDomain->getInnerHorizontalSize(); ++j) {
    //         int liveNeighbors = countAliveNeighbors(i, j);
    //         uint8_t cellValue = dataDomain->getInnerElementAt(i, j);
    //         uint8_t result = cellValue * transitionFunction(liveNeighbors, SMIN, SMAX) + (1 - cellValue) * transitionFunction(liveNeighbors, BMIN, BMAX);

    //         dataDomainBuffer->setInnerElementAt(i, j, result);
    //     }
    // }
}

int AMXSolver::countAliveNeighbors(int y, int x) {
    int aliveNeighbors = 0;

    for (int i = -RADIUS; i <= RADIUS; ++i) {
        for (int j = -RADIUS; j <= RADIUS; ++j) {
            if (i == 0 && j == 0)
                continue;
            aliveNeighbors += dataDomain->getInnerElementAt(y + i, x + j);
        }
    }

    return aliveNeighbors;
}

void AMXSolver::fillHorizontalBoundaryConditions() {
    for (int h = 0; h < dataDomain->getHorizontalHaloSize(); ++h) {
        for (int j = 0; j < dataDomain->getInnerHorizontalSize(); ++j) {
            size_t topIndex = (dataDomain->getHorizontalHaloSize() + h) * dataDomain->getFullHorizontalSize() + dataDomain->getHorizontalHaloSize() + j;
            size_t bottomIndex = topIndex + (dataDomain->getInnerHorizontalSize()) * dataDomain->getFullHorizontalSize();
            uint8_t value = dataDomain->getElementAt(topIndex);
            dataDomain->setElementAt(bottomIndex, value);
        }

        for (int j = 0; j < dataDomain->getInnerHorizontalSize(); ++j) {
            size_t topIndex = (h)*dataDomain->getFullHorizontalSize() + dataDomain->getHorizontalHaloSize() + j;
            size_t bottomIndex = topIndex + (dataDomain->getInnerHorizontalSize()) * dataDomain->getFullHorizontalSize();

            uint8_t value = dataDomain->getElementAt(bottomIndex);
            dataDomain->setElementAt(topIndex, value);
        }
    }
}

void AMXSolver::fillVerticalBoundaryConditions() {
    for (int h = 0; h < dataDomain->getHorizontalHaloSize(); ++h) {
        for (int i = 0; i < dataDomain->getFullHorizontalSize(); ++i) {
            size_t leftIndex = i * dataDomain->getFullHorizontalSize() + h;
            size_t rightIndex = leftIndex + dataDomain->getInnerHorizontalSize();
            uint8_t value = dataDomain->getElementAt(rightIndex);
            dataDomain->setElementAt(leftIndex, value);
        }

        for (int i = 0; i < dataDomain->getFullHorizontalSize(); ++i) {
            size_t leftIndex = i * dataDomain->getFullHorizontalSize() + dataDomain->getHorizontalHaloSize() + h;
            size_t rightIndex = leftIndex + dataDomain->getInnerHorizontalSize();
            uint8_t value = dataDomain->getElementAt(leftIndex);
            dataDomain->setElementAt(rightIndex, value);
        }
    }
}
